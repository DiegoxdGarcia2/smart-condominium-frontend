================================================================================
üìã INFORMACI√ìN COMPLETA DEL BACKEND - RESERVAS (RESERVATIONS)
================================================================================
Fecha: 12 de septiembre de 2025
Proyecto: Smart Condominium Backend - Fase 3
================================================================================

üîó 1. RUTAS DE API DISPONIBLES:
================================================================================

‚úÖ GET    /api/administration/reservations/           - Listar todas las reservas
‚ùå POST   /api/administration/reservations/           - Crear nueva reserva (ERROR 400)
‚úÖ GET    /api/administration/reservations/{id}/      - Obtener reserva espec√≠fica
‚úÖ PUT    /api/administration/reservations/{id}/      - Actualizar reserva completa
‚úÖ PATCH  /api/administration/reservations/{id}/      - Actualizar reserva parcial
‚úÖ DELETE /api/administration/reservations/{id}/      - Eliminar reserva

üìã ESTADO ACTUAL SEG√öN LOGS:
- GET: ‚úÖ Funciona correctamente (status 200)
- POST: ‚ùå Error 400 Bad Request (visto en logs m√∫ltiples veces)
- PATCH: ‚úÖ Funciona (visto en logs: status 200)
- PUT/DELETE: ‚úÖ Disponible (ModelViewSet completo)

üö® ERRORES OBSERVADOS EN LOGS:
[12/Sep/2025 00:55:19] "POST /api/administration/reservations/ HTTP/1.1" 400 40
[12/Sep/2025 00:55:34] "POST /api/administration/reservations/ HTTP/1.1" 400 40
[12/Sep/2025 00:59:44] "POST /api/administration/reservations/ HTTP/1.1" 400 82

================================================================================
üèóÔ∏è 2. MODELO DEL BACKEND (Reservation):
================================================================================

üìÇ Archivo: administration/models.py
üìç L√≠neas: 145-186

class Reservation(models.Model):
    """Modelo para las reservas de √°reas comunes"""
    
    # OPCIONES DE ESTADO:
    STATUS_CHOICES = [
        ('Pendiente', 'Pendiente'),     # Default
        ('Confirmada', 'Confirmada'),
        ('Cancelada', 'Cancelada'),
    ]
    
    # CAMPOS DEL MODELO:
    common_area = models.ForeignKey(
        CommonArea,                     # Relaci√≥n con √°rea com√∫n
        on_delete=models.CASCADE,
        verbose_name="√Årea com√∫n"
    )
    
    resident = models.ForeignKey(
        User,                          # Relaci√≥n con usuario
        on_delete=models.CASCADE,
        verbose_name="Residente"
    )
    
    start_time = models.DateTimeField(
        verbose_name="Fecha y hora de inicio"
    )
    
    end_time = models.DateTimeField(
        verbose_name="Fecha y hora de fin"
    )
    
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='Pendiente',           # Valor por defecto
        verbose_name="Estado"
    )
    
    total_paid = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        verbose_name="Monto pagado"
    )
    
    created_at = models.DateTimeField(
        auto_now_add=True,             # Auto-generado
        verbose_name="Fecha de creaci√≥n"
    )
    
    # METADATOS:
    class Meta:
        verbose_name = "Reserva"
        verbose_name_plural = "Reservas"
        ordering = ['-start_time']     # Ordenado por fecha descendente
        
    def __str__(self):
        return f"{self.common_area.name} - {self.resident.get_full_name()} ({self.start_time.strftime('%d/%m/%Y %H:%M')})"

================================================================================
üìù 3. SERIALIZER DEL BACKEND:
================================================================================

üìÇ Archivo: administration/serializers.py
üìç L√≠neas: 107-121

class ReservationSerializer(serializers.ModelSerializer):
    """Serializer para el modelo Reservation"""
    
    # CAMPOS ADICIONALES DE SOLO LECTURA:
    common_area_name = serializers.CharField(
        source='common_area.name', 
        read_only=True
    )
    resident_name = serializers.CharField(
        source='resident.get_full_name', 
        read_only=True
    )
    resident_email = serializers.CharField(
        source='resident.email', 
        read_only=True
    )
    
    class Meta:
        model = Reservation
        fields = [
            'id',                  # Auto-generado
            'common_area',         # ID del √°rea com√∫n (REQUERIDO)
            'common_area_name',    # Nombre del √°rea (READ-ONLY)
            'resident',            # ID del residente (REQUERIDO)
            'resident_name',       # Nombre del residente (READ-ONLY)
            'resident_email',      # Email del residente (READ-ONLY)
            'start_time',          # Fecha/hora inicio (REQUERIDO)
            'end_time',            # Fecha/hora fin (REQUERIDO)
            'status',              # Estado (OPCIONAL)
            'total_paid',          # Monto pagado (REQUERIDO)
            'created_at'           # Fecha creaci√≥n (READ-ONLY)
        ]
        read_only_fields = ['created_at']

================================================================================
üéØ 4. VIEWSET DEL BACKEND CON VALIDACIONES ESPECIALES:
================================================================================

üìÇ Archivo: administration/views.py
üìç L√≠neas: 115-169

class ReservationViewSet(viewsets.ModelViewSet):
    """ViewSet para gestionar las reservas de √°reas comunes"""
    queryset = Reservation.objects.all()
    serializer_class = ReservationSerializer
    permission_classes = [IsAuthenticated]  # Requiere JWT Token
    
    def get_queryset(self):
        """Optimizar consultas incluyendo √°rea com√∫n y residente relacionados"""
        return Reservation.objects.select_related('common_area', 'resident').order_by('-start_time')
    
    def create(self, request, *args, **kwargs):
        """
        Crear una nueva reserva con validaci√≥n de conflictos de horario
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Extraer datos validados
        common_area = serializer.validated_data['common_area']
        start_time = serializer.validated_data['start_time']
        end_time = serializer.validated_data['end_time']
        
        # VALIDACI√ìN 1: Fecha de fin posterior a inicio
        if end_time <= start_time:
            return Response(
                {'error': 'La fecha de fin debe ser posterior a la fecha de inicio'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # VALIDACI√ìN 2: Conflictos con reservas confirmadas
        conflicting_reservations = Reservation.objects.filter(
            common_area=common_area,
            status='Confirmada',
            # Verificar solapamiento de horarios
            start_time__lt=end_time,
            end_time__gt=start_time
        )
        
        if conflicting_reservations.exists():
            conflicting_reservation = conflicting_reservations.first()
            return Response(
                {
                    'error': 'Conflicto de horario detectado',
                    'details': f'El √°rea "{common_area.name}" ya est√° reservada desde '
                              f'{conflicting_reservation.start_time.strftime("%d/%m/%Y %H:%M")} '
                              f'hasta {conflicting_reservation.end_time.strftime("%d/%m/%Y %H:%M")} '
                              f'por {conflicting_reservation.resident.get_full_name()}'
                },
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Si no hay conflictos, crear la reserva
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, 
            status=status.HTTP_201_CREATED, 
            headers=headers
        )

FUNCIONALIDADES INCLUIDAS:
‚úÖ CRUD Completo (Create, Read, Update, Delete)
‚úÖ Autenticaci√≥n JWT requerida
‚úÖ Validaci√≥n de conflictos de horario
‚úÖ Validaci√≥n de fechas l√≥gicas
‚úÖ Paginaci√≥n autom√°tica (20 items por p√°gina)
‚úÖ Ordenamiento por fecha descendente
‚úÖ Optimizaci√≥n de consultas con select_related

================================================================================
üìä 5. ESTRUCTURA DE DATOS EXACTA:
================================================================================

TIPOS DE DATOS POR CAMPO:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CAMPO           ‚îÇ TIPO         ‚îÇ REQUERIDO   ‚îÇ DESCRIPCI√ìN                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ id              ‚îÇ INTEGER      ‚îÇ AUTO        ‚îÇ ID √∫nico (auto-generado)       ‚îÇ
‚îÇ common_area     ‚îÇ INTEGER      ‚îÇ ‚úÖ S√ç       ‚îÇ ID del √°rea com√∫n (ForeignKey) ‚îÇ
‚îÇ common_area_name‚îÇ STRING       ‚îÇ READ-ONLY   ‚îÇ Nombre del √°rea com√∫n          ‚îÇ
‚îÇ resident        ‚îÇ INTEGER      ‚îÇ ‚úÖ S√ç       ‚îÇ ID del usuario (ForeignKey)    ‚îÇ
‚îÇ resident_name   ‚îÇ STRING       ‚îÇ READ-ONLY   ‚îÇ Nombre completo del residente  ‚îÇ
‚îÇ resident_email  ‚îÇ STRING       ‚îÇ READ-ONLY   ‚îÇ Email del residente            ‚îÇ
‚îÇ start_time      ‚îÇ DATETIME     ‚îÇ ‚úÖ S√ç       ‚îÇ Fecha/hora inicio (ISO 8601)   ‚îÇ
‚îÇ end_time        ‚îÇ DATETIME     ‚îÇ ‚úÖ S√ç       ‚îÇ Fecha/hora fin (ISO 8601)      ‚îÇ
‚îÇ status          ‚îÇ STRING       ‚îÇ ‚ùå NO       ‚îÇ Estado ('Pendiente' default)   ‚îÇ
‚îÇ total_paid      ‚îÇ DECIMAL      ‚îÇ ‚úÖ S√ç       ‚îÇ Monto (10 d√≠gitos, 2 decimales)‚îÇ
‚îÇ created_at      ‚îÇ DATETIME     ‚îÇ AUTO        ‚îÇ Fecha creaci√≥n (auto-generado) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

VALIDACIONES ESPEC√çFICAS:
- common_area: Debe existir en la tabla CommonArea
- resident: Debe existir en la tabla User
- start_time: Formato ISO 8601 (YYYY-MM-DDTHH:MM:SSZ)
- end_time: Formato ISO 8601, debe ser posterior a start_time
- status: Debe ser uno de: 'Pendiente', 'Confirmada', 'Cancelada'
- total_paid: Debe ser decimal v√°lido (formato: XXXXX.XX)

VALIDACIONES ESPECIALES DE NEGOCIO:
1. end_time > start_time (obligatorio)
2. No solapamiento con reservas confirmadas del mismo √°rea
3. Solo verifica conflictos con reservas con status='Confirmada'

VALORES POR DEFECTO:
- id: Auto-generado por la base de datos
- status: 'Pendiente'
- created_at: Fecha/hora actual

VALORES V√ÅLIDOS PARA STATUS:
- 'Pendiente' (default)
- 'Confirmada'
- 'Cancelada'

================================================================================
üì§ 6. FORMATO PARA POST (CREAR NUEVA RESERVA):
================================================================================

ENDPOINT: POST /api/administration/reservations/
HEADERS REQUERIDOS:
  Authorization: Bearer <jwt_token>
  Content-Type: application/json

‚ö†Ô∏è IMPORTANTE: Los errores 400 indican problemas con el formato de datos

EJEMPLO 1 - RESERVA B√ÅSICA:
{
    "common_area": 1,
    "resident": 2,
    "start_time": "2025-09-15T10:00:00Z",
    "end_time": "2025-09-15T12:00:00Z",
    "total_paid": "150.00"
}

EJEMPLO 2 - RESERVA CON STATUS ESPEC√çFICO:
{
    "common_area": 1,
    "resident": 2,
    "start_time": "2025-09-20T18:00:00Z",
    "end_time": "2025-09-20T22:00:00Z",
    "status": "Confirmada",
    "total_paid": "300.00"
}

EJEMPLO 3 - DIFERENTES FORMATOS DE DATETIME:
{
    "common_area": 2,
    "resident": 3,
    "start_time": "2025-09-25T14:30:00.000Z",    // Con milisegundos
    "end_time": "2025-09-25T17:30:00.000Z",
    "total_paid": "120.00"
}

üö® FORMATOS DATETIME SOPORTADOS:
- "2025-09-15T10:00:00Z"           (ISO 8601 b√°sico)
- "2025-09-15T10:00:00.000Z"       (Con milisegundos)
- "2025-09-15T10:00:00+00:00"      (Con timezone expl√≠cito)
- "2025-09-15 10:00:00"            (Formato simple)

RESPUESTA EXITOSA (201 Created):
{
    "id": 3,
    "common_area": 1,
    "common_area_name": "Sal√≥n de Eventos",
    "resident": 2,
    "resident_name": "Juan P√©rez",
    "resident_email": "juan.perez@email.com",
    "start_time": "2025-09-15T10:00:00Z",
    "end_time": "2025-09-15T12:00:00Z",
    "status": "Pendiente",
    "total_paid": "150.00",
    "created_at": "2025-09-12T01:00:00Z"
}

================================================================================
üîÑ 7. FORMATO PARA PUT/PATCH (ACTUALIZAR RESERVA):
================================================================================

ENDPOINT: PUT /api/administration/reservations/{id}/
ENDPOINT: PATCH /api/administration/reservations/{id}/

DIFERENCIAS:
- PUT: Requiere TODOS los campos obligatorios
- PATCH: Solo los campos que quieres cambiar

EJEMPLO PUT (Actualizaci√≥n completa):
{
    "common_area": 1,
    "resident": 2,
    "start_time": "2025-09-15T09:00:00Z",
    "end_time": "2025-09-15T13:00:00Z",
    "status": "Confirmada",
    "total_paid": "200.00"
}

EJEMPLO PATCH (Solo cambiar status):
{
    "status": "Confirmada"
}

EJEMPLO PATCH (Solo cambiar horario):
{
    "start_time": "2025-09-15T11:00:00Z",
    "end_time": "2025-09-15T14:00:00Z"
}

RESPUESTA EXITOSA (200 OK):
{
    "id": 1,
    "common_area": 1,
    "common_area_name": "Sal√≥n de Eventos",
    "resident": 2,
    "resident_name": "Juan P√©rez",
    "resident_email": "juan.perez@email.com",
    "start_time": "2025-09-15T11:00:00Z",
    "end_time": "2025-09-15T14:00:00Z",
    "status": "Confirmada",
    "total_paid": "200.00",
    "created_at": "2025-09-11T20:30:00Z"
}

================================================================================
üì• 8. FORMATO DE RESPUESTA GET:
================================================================================

ENDPOINT: GET /api/administration/reservations/

RESPUESTA CON PAGINACI√ìN:
{
    "count": 2,
    "next": null,
    "previous": null,
    "results": [
        {
            "id": 1,
            "common_area": 1,
            "common_area_name": "Sal√≥n de Eventos",
            "resident": 2,
            "resident_name": "Juan P√©rez",
            "resident_email": "juan.perez@email.com",
            "start_time": "2025-09-18T18:00:00Z",
            "end_time": "2025-09-18T23:00:00Z",
            "status": "Confirmada",
            "total_paid": "300.00",
            "created_at": "2025-09-11T20:30:00Z"
        },
        {
            "id": 2,
            "common_area": 2,
            "common_area_name": "Piscina",
            "resident": 3,
            "resident_name": "Ana Garc√≠a",
            "resident_email": "ana.garcia@email.com",
            "start_time": "2025-09-14T10:00:00Z",
            "end_time": "2025-09-14T14:00:00Z",
            "status": "Pendiente",
            "total_paid": "150.00",
            "created_at": "2025-09-11T20:31:00Z"
        }
    ]
}

ENDPOINT: GET /api/administration/reservations/{id}/

RESPUESTA RESERVA INDIVIDUAL:
{
    "id": 1,
    "common_area": 1,
    "common_area_name": "Sal√≥n de Eventos",
    "resident": 2,
    "resident_name": "Juan P√©rez",
    "resident_email": "juan.perez@email.com",
    "start_time": "2025-09-18T18:00:00Z",
    "end_time": "2025-09-18T23:00:00Z",
    "status": "Confirmada",
    "total_paid": "300.00",
    "created_at": "2025-09-11T20:30:00Z"
}

================================================================================
‚ö†Ô∏è 9. AN√ÅLISIS DE ERRORES 400 OBSERVADOS:
================================================================================

üö® LOGS DE ERROR DEL SERVIDOR:
[12/Sep/2025 00:55:19] "POST /api/administration/reservations/ HTTP/1.1" 400 40
[12/Sep/2025 00:55:34] "POST /api/administration/reservations/ HTTP/1.1" 400 40
[12/Sep/2025 00:59:44] "POST /api/administration/reservations/ HTTP/1.1" 400 82

POSIBLES CAUSAS DE ERROR 400:

‚ùå PROBLEMA 1: IDs inv√°lidos
   CAUSA: common_area o resident con ID que no existe
   VERIFICAR: 
   - CommonArea IDs v√°lidos: 1, 2, 3, 4, 5, 10
   - User IDs v√°lidos: 1, 2, 3, 4
   
‚ùå PROBLEMA 2: Formato de datetime incorrecto
   CAUSA: start_time o end_time en formato no v√°lido
   FORMATOS CORRECTOS:
   ‚úÖ "2025-09-15T10:00:00Z"
   ‚úÖ "2025-09-15T10:00:00.000Z"
   ‚úÖ "2025-09-15T10:00:00+00:00"
   ‚ùå "2025-09-15 10:00" (incorrecto)
   ‚ùå "15/09/2025 10:00" (incorrecto)

‚ùå PROBLEMA 3: Validaci√≥n de fechas
   CAUSA: end_time <= start_time
   SOLUCI√ìN: Asegurar que end_time sea posterior a start_time

‚ùå PROBLEMA 4: Formato de decimal incorrecto
   CAUSA: total_paid en formato no v√°lido
   FORMATOS CORRECTOS:
   ‚úÖ "150.00"
   ‚úÖ "150.50" 
   ‚úÖ "1500.00"
   ‚ùå 150 (sin comillas)
   ‚ùå "150" (sin decimales)

‚ùå PROBLEMA 5: Status inv√°lido
   CAUSA: status con valor no permitido
   VALORES V√ÅLIDOS:
   ‚úÖ "Pendiente"
   ‚úÖ "Confirmada"
   ‚úÖ "Cancelada"
   ‚ùå "Pending" (incorrecto)
   ‚ùå "Confirmed" (incorrecto)

‚ùå PROBLEMA 6: Campos faltantes
   CAMPOS OBLIGATORIOS PARA POST:
   ‚úÖ common_area (integer)
   ‚úÖ resident (integer)
   ‚úÖ start_time (datetime string)
   ‚úÖ end_time (datetime string)
   ‚úÖ total_paid (decimal string)

‚ùå PROBLEMA 7: Headers incorrectos
   HEADERS REQUERIDOS:
   ‚úÖ Authorization: Bearer <valid_jwt_token>
   ‚úÖ Content-Type: application/json

================================================================================
üîß 10. DATOS DE REFERENCIA PARA TESTING:
================================================================================

IDS V√ÅLIDOS PARA TESTING:

üìç COMMON AREAS DISPONIBLES:
- ID: 1, Name: "Sal√≥n de Eventos", Price: $300.00
- ID: 2, Name: "Piscina", Price: $150.00
- ID: 3, Name: "Cancha de Tenis", Price: $100.00
- ID: 4, Name: "Gimnasio", Price: $50.00
- ID: 5, Name: "Terraza BBQ", Price: $120.00
- ID: 10, Name: "Sala de Reuniones", Price: $75.00

üë• USUARIOS DISPONIBLES:
- ID: 1, Name: "Mar√≠a Administradora", Email: "admin@smartcondo.com"
- ID: 2, Name: "Juan P√©rez", Email: "juan.perez@email.com"
- ID: 3, Name: "Ana Garc√≠a", Email: "ana.garcia@email.com"
- ID: 4, Name: "Carlos Seguridad", Email: "carlos.seguridad@email.com"

üìÖ RESERVAS EXISTENTES (para evitar conflictos):
- Reserva 1: Sal√≥n de Eventos, Juan P√©rez, 18/09/2025 18:00-23:00, Confirmada
- Reserva 2: Piscina, Ana Garc√≠a, 14/09/2025 10:00-14:00, Pendiente

================================================================================
üß™ 11. EJEMPLOS DE TESTING CON CURL:
================================================================================

# 1. OBTENER TOKEN DE AUTENTICACI√ìN:
curl -X POST http://localhost:8000/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"email":"juan.perez@email.com","password":"password123"}'

# 2. LISTAR TODAS LAS RESERVAS:
curl -X GET http://localhost:8000/api/administration/reservations/ \
  -H "Authorization: Bearer <tu_token_aqui>"

# 3. CREAR NUEVA RESERVA (FORMATO CORRECTO):
curl -X POST http://localhost:8000/api/administration/reservations/ \
  -H "Authorization: Bearer <tu_token_aqui>" \
  -H "Content-Type: application/json" \
  -d '{
    "common_area": 3,
    "resident": 2,
    "start_time": "2025-09-25T16:00:00Z",
    "end_time": "2025-09-25T18:00:00Z",
    "total_paid": "100.00"
  }'

# 4. CREAR RESERVA CON STATUS ESPEC√çFICO:
curl -X POST http://localhost:8000/api/administration/reservations/ \
  -H "Authorization: Bearer <tu_token_aqui>" \
  -H "Content-Type: application/json" \
  -d '{
    "common_area": 4,
    "resident": 3,
    "start_time": "2025-09-30T07:00:00Z",
    "end_time": "2025-09-30T09:00:00Z",
    "status": "Confirmada",
    "total_paid": "50.00"
  }'

# 5. ACTUALIZAR STATUS DE RESERVA:
curl -X PATCH http://localhost:8000/api/administration/reservations/1/ \
  -H "Authorization: Bearer <tu_token_aqui>" \
  -H "Content-Type: application/json" \
  -d '{"status": "Confirmada"}'

# 6. ACTUALIZAR HORARIO DE RESERVA:
curl -X PATCH http://localhost:8000/api/administration/reservations/2/ \
  -H "Authorization: Bearer <tu_token_aqui>" \
  -H "Content-Type: application/json" \
  -d '{
    "start_time": "2025-09-14T11:00:00Z",
    "end_time": "2025-09-14T15:00:00Z"
  }'

# 7. ELIMINAR RESERVA:
curl -X DELETE http://localhost:8000/api/administration/reservations/2/ \
  -H "Authorization: Bearer <tu_token_aqui>"

================================================================================
üö® 12. RESOLUCI√ìN DE PROBLEMAS ESPEC√çFICOS:
================================================================================

üîç DEBUGGING DEL ERROR 400:

1. **VERIFICAR FORMATO JSON**:
   ‚úÖ Usar comillas dobles para strings
   ‚úÖ No trailing commas
   ‚úÖ Estructura v√°lida

2. **VERIFICAR IDS EXISTEN**:
   ‚úÖ common_area: debe existir en CommonArea
   ‚úÖ resident: debe existir en User

3. **VERIFICAR FORMATO DATETIME**:
   ‚úÖ Usar formato ISO 8601
   ‚úÖ Incluir timezone (Z o +00:00)
   ‚úÖ end_time > start_time

4. **VERIFICAR DECIMAL**:
   ‚úÖ total_paid como string: "150.00"
   ‚úÖ M√°ximo 10 d√≠gitos, 2 decimales

5. **VERIFICAR STATUS**:
   ‚úÖ Solo: "Pendiente", "Confirmada", "Cancelada"
   ‚úÖ Respetar may√∫sculas/min√∫sculas

EJEMPLO DE REQUEST PROBLEM√ÅTICO (Error 400):
{
    "common_area": 999,                    // ‚ùå ID no existe
    "resident": 1,
    "start_time": "2025-09-15 10:00",      // ‚ùå Formato incorrecto
    "end_time": "2025-09-15T09:00:00Z",    // ‚ùå Anterior a start_time
    "status": "Pending",                   // ‚ùå Status inv√°lido
    "total_paid": 150                      // ‚ùå No es string
}

EJEMPLO DE REQUEST CORRECTO (Success 201):
{
    "common_area": 1,                      // ‚úÖ ID v√°lido
    "resident": 2,                         // ‚úÖ ID v√°lido
    "start_time": "2025-09-15T10:00:00Z",  // ‚úÖ Formato correcto
    "end_time": "2025-09-15T12:00:00Z",    // ‚úÖ Posterior a start
    "status": "Pendiente",                 // ‚úÖ Status v√°lido
    "total_paid": "150.00"                 // ‚úÖ String decimal
}

================================================================================
üí° 13. RECOMENDACIONES PARA EL FRONTEND:
================================================================================

1. ‚úÖ **VALIDACI√ìN PREVIA**:
   - Verificar que los IDs existen antes de enviar
   - Validar formato de fechas en el frontend
   - Asegurar que end_time > start_time
   - Formatear total_paid como string decimal

2. ‚úÖ **MANEJO DE ERRORES**:
   - Capturar errores 400 espec√≠ficos
   - Mostrar mensajes de validaci√≥n claros
   - Manejar conflictos de horario
   - Validar disponibilidad antes de enviar

3. ‚úÖ **UX MEJORADA**:
   - Calendario visual para selecci√≥n de fechas
   - Verificaci√≥n de disponibilidad en tiempo real
   - Confirmaci√≥n antes de reservar
   - Estados visuales claros

4. ‚úÖ **OPTIMIZACIONES**:
   - Cache de √°reas comunes y usuarios
   - Validaci√≥n de conflictos local
   - Auto-c√°lculo de total_paid basado en √°rea
   - Sugerencias de horarios disponibles

================================================================================
üèÅ RESUMEN EJECUTIVO:
================================================================================

‚ùå ESTADO GENERAL: PARCIALMENTE FUNCIONAL
‚úÖ GET/PATCH/PUT/DELETE: OPERATIVOS
‚ùå POST: ERROR 400 (requiere debugging de formato)
‚úÖ AUTENTICACI√ìN: JWT IMPLEMENTADA Y FUNCIONANDO
‚úÖ VALIDACIONES ESPECIALES: CONFLICTOS DE HORARIO
‚úÖ PAGINACI√ìN: ACTIVADA Y FUNCIONANDO

PR√ìXIMOS PASOS PARA RESOLVER POST:
1. Verificar formato exacto de datos enviados
2. Confirmar IDs v√°lidos en common_area y resident
3. Validar formato ISO 8601 en datetime fields
4. Asegurar total_paid como string decimal
5. Verificar headers y autenticaci√≥n

================================================================================
üìû SOPORTE T√âCNICO:
================================================================================

Para resolver el error 400 en POST:
1. Activar logs detallados en Django settings
2. Agregar print statements en el ViewSet
3. Verificar datos exactos enviados vs esperados
4. Probar con datos m√≠nimos v√°lidos
5. Usar herramientas como Postman para debugging

================================================================================
FIN DEL DOCUMENTO
================================================================================
